# Shopping Mall Practical Project

## 1.搭建项目Maven结构

![mall-hierarchy.drawio](https://cdn.jsdelivr.net/gh/Aurora0201/ImageStore@main/img/upgit_20230321_1679374260.png)

## 2.依赖分析

**common**

+ lombok的依赖

**bean**

+ lombok的依赖

**mapper**

+ spring-boot-starter的依赖
+ mybatis的依赖
+ mysql-connector的依赖
+ druid-starter的依赖
+ bean的依赖

**service**

+ mapper的依赖
+ common的依赖

**api**

+ service的依赖
+ spring-boot-starter-web的依赖
+ spring-boot-starter-test的依赖
+ 

## 3.软件开发步骤

+ 问题定义/提出问题
+ 可⾏性分析（技术、成本、法律法规）
+ 需求分析（需求采集、需求分析）---->甲⽅
+ 概要设计
    + 架构设计（技术选型、架构模式、项⽬搭建）
    + 数据库设计
    + UI设计
    + 业务流程设计
+ 详细设计
    + 实现步骤（业务流程的实现细节）
+ 编码
    + 根据设计好的实现步骤进⾏代码实现
    + 开发过程中开发者要进⾏单元测试
+ 测试
    + 集成测试
    + 功能测试（⿊盒）
    + 性能测试（⽩盒）
+ 交付/部署实施



## 4.导入数据库表

导入mall.sql文件



## 5.业务功能设计

### 1.用户系统

用户系统需要有下面的功能

+ 用户注册
+ 用户登录
+ 退出登录
+ 日志管理
+ 单点登录

![user_login.drawio](https://cdn.jsdelivr.net/gh/Aurora0201/ImageStore@main/img/upgit_20230321_1679400038.png)

**用户登录和用户注册**

使用枚举类储存所有的状态，通过Service层提供的CRUD接口即可完成，两个功能的实现



**登录验证**

在访问购物车和我的信息等页面需要用户登录才能获得数据，但是因为本项目是前后端分离项目，无法使用单体项目中的session，所以这里我们使用JWT来进行登录的验证

+ token生成：提供JWT工具类来生成Token
+ 设置拦截器：在访问敏感资源时拦截并验证token，过滤不合法的token
+ token存储：登录成功后在sessionStorage存储token



### 2.首页功能

**轮播图的获取**

轮播图的信息存储在数据库中，我们需要从数据库中获取轮播图的信息然后展示在首页上

+ 数据库的查询：简单的单表查询返回List
+ 前端的渲染：通过ajax请求到数据后，通过在标签绑定列表渲染，**在数据挂载后再执行轮播的JS代码**



**分类列表的获取**

分类列表的信息存储在数据库中，通过level字段来区分分类的层级，通过parent_id来指向父级分类

+ 数据存储结构：提供CategoryEnhance类，增强字段`List<CategoryEnhance>`
+ 数据库表查询：根据parent_id查询分类，首先通过*parent_id = 0*查询查出一级分类的字段，通过分布查询递归调用查询
+ 前端数据渲染：获得后端数据后，通过分级绑定列表渲染，在数据挂载后执行分类JS代码



**商品推荐**

根据商品上新时间获取商品推荐

+ 存储数据结构：提供ProductEnhance类，增强字段`List<ProductImg>`
+ 数据库表查询：使用分步查询，先查出最新的三个商品，在根据商品id分步查询出商品的图片



### 3.商品系统

**详情页面**

用户点击商品图片跳转到详情页面后，我们需要通过向后端传入商品Id来获取对应商品的信息，动态的渲染页面，首先看上面的面板：

+ 左边的部分，是略缩图和细节图
+ 右边是商品的标题，还有SKU的信息

这里就涉及了三表的查询，通过productId来查询对应商品的信息，这里我们的解决方案是提供一个DTO对象`ProductDetailDTO`，有三个字段：

+ `Product`
+ `List<ProductImg>`
+ `List<ProductSku>`



**商品详细参数**

用户通过滚轮往下滑时，向后端请求商品的详细参数信息，只涉及单表的查询，直接实现即可



## 6.使用Redis减轻数据库压力

### 1.Redis使用场景

Redis缓存的数据一般来说有下面的特点：

+ 写的次数较少或者几乎不写，但是读的次数相当多的数据
+ 对于数据一致性要求较低，读次数较多的数据



### 2.使用Redis缓存数据

使用Redis的流程：

+ 首先从Redis中拿
    + 如果有直接返回结果
    + 没有则向数据库查询
+ 在数据库查询获得结果
    + 如果没有就是不存在所需的数据，返回空
    + 如果有，就存入Redis中，返回结果



### 3.缓存击穿

在互联网开发中，高并发的情况下，可能会出现缓存及击穿的情况，**缓存击穿**是指在高并发的场景下，如果存在1000个并发的请求同时访问Redis中不存在的数据，在Spring容器中Service层是单例的，所以会启动1000个进程来访问数据库，这样就会对数据库造成极大的压力，可能会导致系统宕机，解决方法有：

+ 双层检测锁，在访问数据库之前加上**同步锁synchronize**，在访问数据库前再访问一次Redis看看是否已经有了需要的数据



### 4.缓存穿透

大量的请求访问数据中不存在的数据，首先在Redis中无法命中，最终所有的请求都会访问数据库，让数据库承受巨大的压力，解决方案有：

+ 当数据库查询出一个空数据时，直接往Redis中写入一个非空的数据，**这个非空的数据要设置过期时间比如10s**，这样在10秒内所有的请求都会去查询Redis而不会去查询数据库



### 5.缓存雪崩

缓存中大量的数据集中过期，导致请求这些数据的大量并发请求会同时访问数据库，解决方案有：

+ 将缓存中的数据设置成不同的过期时间
+ 在访问洪峰前缓存热点数据，过期时间设置到流量较低的时段
